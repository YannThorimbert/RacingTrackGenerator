<!DOCTYPE html>
<html>
<head>
    <meta charset="ISO-8859-1">
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>

<canvas id="canvas2d" width="500" height="500">
Your browser does not support the HTML5 canvas tag.</canvas>

<script>
    var PI = Math.PI;
    var c = document.getElementById("canvas2d");
    var W = c.width;
    var H = c.height;
    var ctx = c.getContext("2d");
    ctx.beginPath();

    // var seed = 193;
    // function rand(){ //fake rand
    //     var x = Math.sin(seed++) * 10000;
    //     return x - Math.floor(x);
    // }
    function rand(){
        return Math.random();
    }

    function random_choice(a){
        return a[Math.floor(rand() * a.length)];
    }

    function get_rand(m,M){
        return m + rand() * (M-m);
    }

    function compute_distance(p1, p2){
        return Math.hypot(p1[0]-p2[0], p1[1]-p2[1]);
    }

    function compute_distance_point_line(x, y, q){
        var P = get_nearest_point_on_line([x,y], q);
        return compute_distance(P, [x,y]);
    }

    function compute_distance_point_line2(x, y, q){
        var dx = q[2] - q[0];
        var dy = q[3] - q[1];
        if (dx == 0){
            return Math.abs(q[0] - x);
        }
        else{
            var a = dy / dx;
            var b = q[1] - a*q[0];
            return Math.abs(y - a*x - b) / Math.sqrt(1 + a*a);
        }
    }

    function compute_min_dist_segments(q1, q2){
        var a = compute_distance([q1[0], q1[1]], [q2[0], q2[1]]);
        var b = compute_distance([q1[0], q1[1]], [q2[2], q2[3]]);
        var c = compute_distance([q1[2], q1[3]], [q2[0], q2[1]]);
        var d = compute_distance([q1[2], q1[3]], [q2[2], q2[3]]);
        return Math.min(a,b,c,d);
    }

    function get_current_angle(){
        return Math.atan2(current_orientation[1],current_orientation[0]);
    }

    function compute_norm(v){
        return Math.sqrt(v[0]*v[0] + v[1]*v[1]);
    }

    function get_normalized(v){
        var L = compute_norm(v);
        return [v[0]/L, v[1]/L];
    }


    function compute_relative_angle(v1,v2){
        if(close_numbers(v1[0]/v1[1],v2[0]/v2[1]))
            return 0;
        var Lv1 = compute_norm(v1);
        var Lv2 = compute_norm(v2);
        var cos_t = (v1[0]*v2[0] + v1[1]*v2[1]) / (Lv1*Lv2);
        var det = v1[0]*v2[1] - v1[1]*v2[0];
        var sign = 1.;
        if(det > 0)
            sign = -1.;
        return sign * Math.acos(cos_t);
    }

    function get_rotated_vector(v, delta){
        return [Math.cos(delta)*v[0]-Math.sin(delta)*v[1],
                Math.sin(delta)*v[0]+Math.cos(delta)*v[1]];
    }

    function control_collisions(){
        var mll = MARGIN_LINE_LINE;
        var mcl = MARGIN_CURVE_LINE;
        var mcc = MARGIN_CURVE_CURVE;
        MARGIN_LINE_LINE = 0;
        MARGIN_CURVE_LINE = 0;
        MARGIN_CURVE_CURVE = 0;
        for(var i=0; i<track_history.length; i++){
            what = track_history[i];
            var collide;
            if(what[0] == "curve"){
                if (what[1] < MIN_CURVE_RADIUS)
                    return true;
                // console.log("CONTROLLING curve", i, what[1]);
                collide = check_self_collisions_curve(what, i, true);
            }
            else{
                // console.log("CONTROLLING line", i, what[1]);
                collide = check_self_collisions_straight(what, i, true);
            }
            if(collide>=0 && collide != (i+1)%track_history.length){
                var what2 = track_history[collide];
                if(what[0] == "curve" && what2[0] == "straight"){
                    // console.log("Collision", what[0], i, track_history[collide][0],collide);
                    return true;
                }
                else if(what[0] == "straight" && what2[0] == "curve"){
                    // console.log("Collision", what[0], i, track_history[collide][0],collide);
                    return true;
                }
                else if(what[0] == "straight" && what2[0] == "straight"){
                    // console.log("Collision", what[0], i, track_history[collide][0],collide);
                    return true;
                }

            }
        }
        MARGIN_LINE_LINE = mll;
        MARGIN_CURVE_LINE = mcl;
        MARGIN_CURVE_CURVE = mcc;
        return false;
    }

    function add_to_centerline(p){
        var tolerance = STL_RES / 2;
        var last = centerline.length - 1;
        if(compute_distance(centerline[last], p) > tolerance)
            centerline.push(p);
    }

    function make_straight(length){
        var new_x = x + current_orientation[0] * length;
        var new_y = y + current_orientation[1] * length;
        if(drawing){
            ctx.moveTo(x,y);
            ctx.lineTo(new_x, new_y);
            if(STL_RES > 0){
                var N = length / STL_RES;
                var x1 = x;
                var y1 = y;
                for(var i=0; i<N; i++){
                    // ctx.fillRect(x1,y1,4,4);
                    add_to_centerline([x1,y1]);
                    x1 += current_orientation[0] * STL_RES;
                    y1 += current_orientation[1] * STL_RES;
                }
                add_to_centerline([new_x,new_y]);
            }
        }
        return [new_x, new_y, x, y];
    }

    function check_line_line_collision(qf, qg){ //f is the newly created straight
        var d1 = compute_distance_point_line(qf[0],qf[1], qg);
        var d2 = compute_distance_point_line(qf[2],qf[3], qg);
        if(d1 < MARGIN_LINE_LINE || d2 < MARGIN_LINE_LINE){
            return compute_min_dist_segments(qf, qg) < MARGIN_LINE_LINE;
        }
        var f = [qf[2]-qf[0], qf[3]-qf[1]];
        var g = [qg[2]-qg[0], qg[3]-qg[1]];
        var min_f_y = Math.min(qf[1], qf[3]);
        var max_f_y = Math.max(qf[1], qf[3]);
        var min_f_x = Math.min(qf[0], qf[2]);
        var max_f_x = Math.max(qf[0], qf[2]);
        var min_g_y = Math.min(qg[1], qg[3]);
        var max_g_y = Math.max(qg[1], qg[3]);
        var min_g_x = Math.min(qg[0], qg[2]);
        var max_g_x = Math.max(qg[0], qg[2]);
        if(f[0] == 0){ //f has infinite slope
            if(g[1] == 0){
                return qg[1] <= max_f_y && qg[1] >= min_f_y;
            }
            else{ //invert x and y
                return true; //TODO, meanwhile lets pretend its a collision
            }
        }
        else if(g[0] == 0){ //g has infinite slope
            if(f[1] == 0){
                return qf[1] <= max_g_y && qf[1] >= min_g_y;
            }
            else{ //invert x and y
                return true; //TODO, meanwhile lets pretend its a collision
            }
        }
        var sf = f[1] / f[0];
        var sg = g[1] / g[0];
        if(sf == sg) //parallel lines (or colinear)
            return false;
        var x_col = (qg[1] - qf[1] + sf*qf[0] - sg*qg[0]) / (sf - sg);
        if(x_col >= min_f_x && x_col <= max_f_x){
            return x_col >= min_g_x && x_col <= max_g_x;
        }
        return false;
    }

    function check_curve_curve_collision(r1, c1, r2, c2){
        return compute_distance(c1, c2) <= r1 + r2 + MARGIN_CURVE_CURVE;
    }

    function get_nearest_point_on_line(p, q){
        var qx = q[2] - q[0];
        var qy = q[3] - q[1];
        var px = p[0] - q[0];
        var py = p[1] - q[1];
        var slope = qy / qx; //inverse of slope actually, but doesnt matter
        var Ix = (qx*px + qy*py) / (qx + qy*slope);
        var Iy = slope*Ix;
        Ix += q[0];
        Iy += q[1];
        return [Ix,Iy];
    }

    // old version not taking arc into acount
    function check_curve_line_collision_security(c, r, q){
        var d1 = compute_distance(c,[q[0],q[1]]);
        var d2 = compute_distance(c,[q[2],q[3]]);
        if (d1 <= r + MARGIN_CURVE_LINE || d2 <= r + MARGIN_CURVE_LINE)
            return true;
        var P = get_nearest_point_on_line(c, q);
        var distance = compute_distance(P, c);
        if(distance <= r + MARGIN_CURVE_LINE){
            var min_y = Math.min(q[1],q[3]); //min y coordinate
            var max_y = Math.max(q[1],q[3]); //max y coordinate
            return P[1] >= min_y && P[1] <= max_y;
        }
        else{
            return false;
        }
    }

    // function check_curve_line_collision(curve, q){
    //     var r = curve[1];
    //     var side = curve[2];
    //     var delta_angle = curve[3];
    //     var c = curve[4];
    //     var start_angle = curve[5];
    //     var final_angle = start_angle;
    //     if(side>0)
    //         final_angle -= delta_angle;
    //     else
    //         final_angle += delta_angle;
    //     var d = compute_distance_point_line(c[0],c[1], q);
    //     if(r == 0)
    //         return d <= r + MARGIN_CURVE_LINE;
    //     // if(true){
    //     if(d <= r + MARGIN_CURVE_LINE){
    //         var x1 = q[0] - c[0];
    //         var y1 = q[1] - c[1];
    //         var x2 = q[2] - c[0];
    //         var y2 = q[3] - c[1];
    //         var dx = x2 - x1;
    //         var dy = y2 - y1;
    //         if(dx == 0){
    //             throw "not implemented";
    //         }
    //         else{ //below, everything is translated by -c.
    //             var slope = dy / dx;
    //             var yint = y1 - slope*x1;
    //             var A = 1 + slope*slope;
    //             var B = 2*slope*yint;
    //             var C = yint*yint - r*r;
    //             var delta = B*B - 4*A*C;
    //             if(delta < 0)
    //                 return false;
    //             var x_col1 = (-B + Math.sqrt(delta))/(2*A);
    //             var y_col1 = slope*x_col1 + yint;
    //             var d1 = compute_norm([x_col1,y_col1]);
    //             // console.log("****", d1, r);
    //             //by symmetry, d1 = d2
    //             var x_col2 = (-B - Math.sqrt(delta))/(2*A);
    //             var y_col2 = slope*x_col2 + yint;
    //             if(d1 > r + MARGIN_CURVE_LINE)
    //                 return false;
    //             else{ // then we still have to check the angle
    //                 var v0 = [1,0];
    //                 var v1 = [x_col1, y_col1];
    //                 var a1 = compute_relative_angle(v0, v1);
    //                 // console.log("ANGLE",a1,start_angle,final_angle);
    //                 if(a1 >= start_angle && a2 <= final_angle){
    //                     return true;
    //                 }
    //                 var v2 = [x_col2,y_col2];
    //                 var a2 = compute_relative_angle(v0, v2);
    //                 if(a2 >= start_angle && a2 <= final_angle){
    //                     return true;
    //                 }
    //                 return check_curve_line_collision_security(c,r,q);
    //             }
    //         }
    //     }
    //     else{
    //         return false;
    //     }
    // }

    function check_self_collisions_straight(straight, current_i, finished){
        var qf = straight[2]; //straight that is candidate to be included
        if(qf.length != 4)
            throw "problem"
        var previous_i = current_i-1;
        if(previous_i < 0)
            previous_i = track_history.length-1;
        for(var i=0; i<track_history.length; i++){
            if (i != previous_i && i != current_i){
                var should_check = true;
                if(finished && i == (current_i+1)%track_history.length)
                    should_check = false;
                if (should_check){
                    var what = track_history[i];
                    if( what[0] == "straight"){
                        var qg = what[2];
                        // console.log("       against line", i);
                        var result = check_line_line_collision(qf,qg);
                    }
                    else{
                        // if(check_curve_line_collision(what,qf))
                        var result = check_curve_line_collision_security(what[4],what[1],qf);
                    }
                    if(result)
                        return i;
                }//end should check
            } //end if previous
        }//end for i
        return -1;
    }

    function check_self_collisions_curve(curve, current_i, finished){
        var r1 = curve[1];
        var c1 = curve[4];
        var previous_i = current_i-1;
        if(previous_i < 0)
            previous_i = track_history.length-1;
        for(var i=0; i<track_history.length; i++){
            if(i != previous_i && i != current_i){
                var should_check = true;
                if(finished && i == (current_i+1)%track_history.length)
                    should_check = false;
                if (should_check){
                    var what = track_history[i];
                    if( what[0] == "curve"){
                        var r2 = what[1];
                        var c2 = what[4];
                        if(check_curve_curve_collision(r1,c1,r2,c2))
                            return i;
                    }
                    else{
                        var q = what[2];
                        // console.log("   ",i,q);
                        if(check_curve_line_collision_security(c1,r1,q))
                            return i;
                    }
                }
            }
        }
        return -1;
    }


    function make_curve(radius, side, delta_angle){
        // if(radius >0 && radius < MIN_CURVE_RADIUS)
        //     throw "forbidden"+radius;
        var a0 = get_current_angle();
        if (side < 0){
            delta_angle *= -1.;
            a0 += PI/2;
        }
        else{
            a0 -= PI/2;
        }
        var to_radius = get_rotated_vector(current_orientation, side);
        var cx = x + to_radius[0]*radius;
        var cy = y + to_radius[1]*radius;
        var a1 = a0 + delta_angle;
        if(drawing){
            // ctx.arc(cx,cy,radius,0,2*PI);
            if(side < 0)
                ctx.arc(cx,cy,radius,a1,a0);
            else
                ctx.arc(cx,cy,radius,a0,a1);
            //
            if(STL_RES > 0){
                var N = Math.floor(radius * Math.abs(delta_angle) / STL_RES)+1;
                var x1 = x;
                var y1 = y;
                var rstl = [-to_radius[0]*radius, -to_radius[1]*radius];
                var delta_angle_stl = delta_angle / N;
                // ctx.fillRect(cx,cy,2,2);
                // ctx.fillRect(x-rstl[0], y-rstl[1], 3,3) // correct
                for(var i=0; i<N; i++){
                    // ctx.arc(x1,y1,3,0,2*PI);
                    // ctx.stroke();
                    // ctx.fillRect(x1,y1,4,4);
                    add_to_centerline([x1,y1]);
                    rstl = get_rotated_vector(rstl, delta_angle_stl);
                    x1 = cx + rstl[0];
                    y1 = cy + rstl[1];
                }
            }
        }
        var new_orientation = get_rotated_vector(current_orientation, delta_angle);
        var new_x = cx + radius*Math.cos(a1);
        var new_y = cy + radius*Math.sin(a1);
        if(STL_RES > 0 && drawing)
            add_to_centerline([new_x,new_y]);
        return [new_x, new_y, new_orientation, [cx,cy], -a0];
    }

    function compute_first_orientation(th){
        var v1 = get_straight_vector(th[th.length-1]);
        return get_normalized(v1);
    }

    function display(what){
        if(what[0] == "curve"){
            console.log("Curve");
            console.log("   Radius :", Math.round(what[1]));
            if(what[2]<0)
                console.log("   Anticlockwise");
            else
                console.log("   Clockwise");
            console.log("   Delta angle :", Math.round(what[3]*180/PI))
            console.log("   Center :", what[4]);
        }
    }

    var centerline = [];
    function draw_track(th){ // th is track history
        console.log("DRAWING", th);
        current_orientation = compute_first_orientation(th);
        x = th[th.length-1][2][2];
        y = th[th.length-1][2][3];
        centerline.push([x,y]);
        // console.log("orientation set to", current_orientation);
        // current_orientation = [1,0];
        // x = START[0];
        // y = START[1];
        drawing = true;
        for(var i=0; i<th.length; i++){
            var new_pos = [];
            var new_orientation = [];
            ctx.beginPath();
            ctx.strokeStyle = colors[i%colors.length];
            var what = th[i];
            // console.log(i, "drawing", what);
            // display(what);
            if(what[0] == "straight"){
                new_pos = make_straight(what[1]);
                new_orientation = current_orientation;
            }
            else if(what[0] == "curve"){
                var data = make_curve(what[1], what[2], what[3]);
                new_pos[0] = data[0];
                new_pos[1] = data[1];
                new_orientation = data[2];
            }
            ctx.stroke();
            x = new_pos[0];
            y = new_pos[1];
            // console.log("       (x,y) = ",x,y);
            current_orientation = new_orientation;
        }
        centerline.pop(); //last point is too close from first point usually
        //drawing = false;
    }

    function is_in_canvas(pos, margin){
        var ok_x = pos[0] > margin && pos[0] < W - margin;
        var ok_y = pos[1] > margin && pos[1] < H - margin;
        return ok_x && ok_y;
    }

    function update_track(){
        var what = "straight";
        if(get_rand(0,1)<PROB_CURVE)
            what = "curve";
        var new_pos = [];
        var new_orientation = [];
        var to_insert;
        var collision;
        var current_i = track_history.length;
        if(what == "straight"){
            var length = get_rand(MIN_STRAIGTH_LENGTH, MAX_STRAIGTH_LENGTH);
            new_pos = make_straight(length);
            new_orientation = current_orientation;
            to_insert = ["straight", length, new_pos];
            collision = check_self_collisions_straight(to_insert, current_i, false);
        }
        else if(what == "curve"){
            var radius = get_rand(MIN_CURVE_RADIUS, MAX_CURVE_RADIUS);
            var side = -PI/2;
            if(get_rand(0,1) < PROB_COUNTERCLOCKWISE_TURN)
                side *= -1;
            // var side = random_choice([PI/2, -PI/2]);
            var delta_angle = get_rand(MIN_CURVE_ANGLE, MAX_CURVE_ANGLE);
            var data = make_curve(radius, side, delta_angle);
            new_pos[0] = data[0];
            new_pos[1] = data[1];
            new_orientation = data[2];
            var center = data[3];
            var start_angle = data[4];
            to_insert = ["curve", radius, side, delta_angle, center, start_angle];
            collision = check_self_collisions_curve(to_insert, current_i, false);
        }
        // var in_canvas = is_in_canvas(new_pos, MAX_CURVE_RADIUS + MARGIN_BORDER);
        var in_canvas = true;
        if(in_canvas && collision<0){
            // console.log("(nx,ny)=",new_pos);
            x = new_pos[0];
            y = new_pos[1];
            current_orientation = new_orientation;
            track_history.push(to_insert);
        }
        else{
            // console.log("Not accepted");
            // track_history.pop();
        }
    }

    // function try_update(what){
    //     var new_pos = [];
    //     var new_orientation = [];
    //     var to_insert;
    //     var collision;
    //     var current_i = track_history.length;
    //     if(what[0] == "straight"){
    //         new_pos = make_straight(what[1]);
    //         new_orientation = current_orientation;
    //         to_insert = what;
    //         collision = check_self_collisions_straight(to_insert, current_i, false);
    //     }
    //     else if(what[0] == "curve"){
    //         var data = make_curve(what[1], what[2], what[3]);
    //         new_pos[0] = data[0];
    //         new_pos[1] = data[1];
    //         new_orientation = data[2];
    //         var center = data[3];
    //         var start_angle = data[4];
    //         to_insert = ["curve", what[1], what[2], what[3], center, start_angle];
    //         collision = check_self_collisions_curve(to_insert, current_i, false);
    //     }
    //     // var in_canvas = is_in_canvas(new_pos, MAX_CURVE_RADIUS + MARGIN_BORDER);
    //     var in_canvas = true;
    //     if(in_canvas && collision<0){
    //         console.log("(nx,ny)=",new_pos);
    //         x = new_pos[0];
    //         y = new_pos[1];
    //         current_orientation = new_orientation;
    //         track_history.push(to_insert);
    //         return true;
    //     }
    //     else{
    //         console.log("Not accepted");
    //         // track_history.pop();
    //         return false;
    //     }
    // }


    function add_to_track(what, i){
        if(i="end"){
            i = track_history.length;
        }
        if(what[0] == "straight"){
            var q = make_straight(what[1]);
            track_history.splice(i,0,["straight", what[1], [q[2],q[3],q[0],q[1]]]);
            x = q[0];
            y = q[1];
        }
        else if(what[0] == "curve"){
            var data = make_curve(what[1], what[2], what[3]);
            x = data[0];
            y = data[1];
            current_orientation = data[2];
            var center = data[3];
            var start_angle = data[4];
            track_history.splice(i,0,["curve", what[1], what[2], what[3],
                                        center, start_angle]);
        }
    }

    function link_points(q1, q2, i){
        if(i == "end"){
            i = track_history.length;
        }
        var link = [q2[0]-q1[0], q2[1]-q1[1]];
        var angle = compute_relative_angle(link, current_orientation);
        add_to_track(["curve", 0, PI/2, angle], i);
        add_to_track(["straight", compute_norm(link)], i+1);
    }

    function get_straight_vector(what){
        return [what[2][2]-what[2][0], what[2][3]-what[2][1]];
    }


    function smooth_corner(n, compute_angle){
        var curve = track_history[n];
        var cx = curve[4][0];
        var cy = curve[4][1];
        var i_before = n-1;
        if(i_before<0)
            i_before = track_history.length - 1;
        var before = track_history[i_before];
        var after = track_history[(n+1)%track_history.length];
        if(curve[0] != "curve" || before[0] != "straight" || after[0] != "straight")
            throw "PROBLEM in smooth corner"; //, curve, before, after);
        ////////////////////////////////////////////////////////////////////////
        var b_v = get_straight_vector(before);
        var b_L = compute_norm(b_v);
        var a_v = get_straight_vector(after);
        var a_L = compute_norm(a_v);
        var angle = compute_relative_angle(b_v, a_v);
        if (angle > 0){
            angle += 2*PI; //wtf i dont know why i need this...
        }
        angle = PI - angle;
        var bissection = get_normalized(b_v);
        bissection = get_rotated_vector(bissection, angle/2)
        var min_length = Math.min(b_L,a_L);
        var r = get_rand(SMOOTH_MIN_RADIUS_FACTOR*min_length,
                            SMOOTH_MAX_RADIUS_FACTOR*min_length)
        if(r < MIN_CURVE_RADIUS)
            return false;
        var vP = [bissection[0]*r, bissection[1]*r];
        var P = [cx + vP[0], cy + vP[1]]; //new curve center
        ////////////////////////////////////////////////////////////////////////
        // now find closest points from P on before (orthogonal projection)
        var b_x = before[2][0] - cx;
        var b_y = before[2][1] - cy;
        var lambda = (vP[0]*b_x + vP[1]*b_y) / (b_x*b_x + b_y*b_y);
        var B = [lambda*b_x + cx, lambda*b_y + cy];
        // now find closest points from P on after (orthogonal projection)
        var a_x = after[2][2] - cx;
        var a_y = after[2][3] - cy;
        var lambda = (vP[0]*a_x + vP[1]*a_y) / (a_x*a_x + a_y*a_y);
        var A = [lambda*a_x + cx, lambda*a_y + cy];
        //////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        before[1] = compute_distance(B, [before[2][0], before[2][1]]); // new length
        before[2] = [before[2][0], before[2][1], B[0], B[1]];
        after[1] = compute_distance(A, [after[2][2], after[2][3]]); // new length
        after[2] = [A[0],A[1],after[2][2],after[2][3]];
        //
        curve[1] = compute_distance(P,A); //new turn radius
        curve[4] = P;
        if(angle > PI){
            angle = 2*PI - angle;
        }
        else {
            curve[2] *= -1;
            angle += 2*PI;
        }
        angle = PI - angle;
        curve[3] = angle;
        return true;
    }

    function random_section(n){
        add_to_track(["curve", 0, PI/2, get_rand(MIN_CURVE_ANGLE, PI/4)], "end");
        add_to_track(["straight", get_rand(MIN_STRAIGTH_LENGTH, MAX_STRAIGTH_LENGTH)], "end");
        for(var k=0; k<n; k++){
            update_track();
        }
        var angle = random_choice([-PI/2,PI/2]);
        add_to_track(["curve", get_rand(MIN_CURVE_RADIUS, 2*MIN_CURVE_RADIUS), angle, get_rand(PI*0.6,PI*0.6)], "end");
        add_to_track(["straight", get_rand(MIN_STRAIGTH_LENGTH, MAX_STRAIGTH_LENGTH)], "end");
    }

    function chicane(){
        add_to_track(["curve", 0, PI/2, get_rand(MIN_CURVE_ANGLE, PI/4)], "end");
        add_to_track(["straight", get_rand(MIN_STRAIGTH_LENGTH, MAX_STRAIGTH_LENGTH)], "end");
        //
        var space_before = get_rand(0,1) < 0.5;
        var space_after = get_rand(0,1) < 0.5;
        var angle_factor = get_rand(0.1, 1);
        var asymL = get_rand(0., 0.9);
        var asymR = get_rand(0., 0.9);
        var sizeL = get_rand(0.5, 2);
        var sizeR = get_rand(1, 4);
        var side = random_choice([1,-1]);
        var L = sizeL*MIN_STRAIGTH_LENGTH;
        var L1 = get_rand((1.-asymL)*L, (1+asymL)*L);
        var L2 = get_rand((1.-asymL)*L, (1+asymL)*L);
        var R = sizeR*MIN_CURVE_RADIUS;
        var R1 = get_rand((1.-asymR)*R, (1+asymR)*R);
        var R2 = get_rand((1.-asymR)*R, (1+asymR)*R);
        var R3 = get_rand((1.-asymR)*R, (1+asymR)*R);
        R1 = Math.max(R1, MIN_CURVE_RADIUS);
        R2 = Math.max(R2, MIN_CURVE_RADIUS);
        R3 = Math.max(R3, MIN_CURVE_RADIUS);
        if(space_before)
            add_to_track(["straight", get_rand(0.3, 1)*MAX_STRAIGTH_LENGTH], "end");
        add_to_track(["curve", R1, side*PI/2, angle_factor*MAX_CURVE_ANGLE/2], "end");
        add_to_track(["straight", L1], "end");
        add_to_track(["curve", R2, -side*PI/2, angle_factor*MAX_CURVE_ANGLE], "end");
        add_to_track(["straight", L2], "end");
        add_to_track(["curve", R2, side*PI/2, angle_factor*MAX_CURVE_ANGLE/2], "end");
        if(space_after)
            add_to_track(["straight", get_rand(0.3, 1)*MAX_STRAIGTH_LENGTH], "end");
        //
        var angle = random_choice([-PI/2,PI/2]);
        add_to_track(["curve", get_rand(MIN_CURVE_RADIUS, 2*MIN_CURVE_RADIUS), angle, get_rand(PI*0.6,PI*0.6)], "end");
        add_to_track(["straight", get_rand(MIN_STRAIGTH_LENGTH, MAX_STRAIGTH_LENGTH)], "end");
    }


    function varying_radius_curve(factor){
        add_to_track(["curve", 0, PI/2, get_rand(MIN_CURVE_ANGLE, PI/4)], "end");
        add_to_track(["straight", get_rand(MIN_STRAIGTH_LENGTH, MAX_STRAIGTH_LENGTH)], "end");
        //
        //TODO: inverser des fois L1 et L2, et R1 R2 R3
        var side = random_choice([1,-1]);
        var R = get_rand(MAX_CURVE_RADIUS/10, MAX_CURVE_RADIUS/4);
        if(factor > 1)
             R = get_rand(MIN_CURVE_RADIUS, 3*MIN_CURVE_RADIUS);
        var N = Math.floor(get_rand(2,5));
        var tot_angle = get_rand(MAX_CURVE_ANGLE/8, MAX_CURVE_ANGLE);
        var dangle = tot_angle / N;
        for(var i=0; i<N; i++){
            if(R < MIN_CURVE_RADIUS || R > MAX_CURVE_RADIUS)
                break;
            add_to_track(["curve", R, side*PI/2, dangle], "end");
            R *= factor;
        }
        //
        var angle = random_choice([-PI/2,PI/2]);
        add_to_track(["curve", get_rand(MIN_CURVE_RADIUS, 2*MIN_CURVE_RADIUS), angle, get_rand(PI*0.6,PI*0.6)], "end");
        add_to_track(["straight", get_rand(MIN_STRAIGTH_LENGTH, MAX_STRAIGTH_LENGTH)], "end");
    }

    function s_curves(){
        add_to_track(["curve", 0, PI/2, get_rand(MIN_CURVE_ANGLE, PI/4)], "end");
        add_to_track(["straight", get_rand(MIN_STRAIGTH_LENGTH, MAX_STRAIGTH_LENGTH)], "end");
        //
        //TODO: inverser des fois L1 et L2, et R1 R2 R3
        var side = random_choice([1,-1]);
        var N = Math.floor(get_rand(2,6));
        for(var i=0; i<N; i++){
            var R = get_rand(MAX_CURVE_RADIUS/4, MAX_CURVE_RADIUS);
            var dangle = get_rand(MIN_CURVE_ANGLE*2, MIN_CURVE_ANGLE*4);
            add_to_track(["curve", R, side*PI/2, dangle], "end");
            side *= -1;
        }
        //
        var angle = random_choice([-PI/2,PI/2]);
        add_to_track(["curve", get_rand(MIN_CURVE_RADIUS, 2*MIN_CURVE_RADIUS), angle, get_rand(PI*0.6,PI*0.6)], "end");
        add_to_track(["straight", get_rand(MIN_STRAIGTH_LENGTH, MAX_STRAIGTH_LENGTH)], "end");
    }

    function hairpin_curve(){
        add_to_track(["curve", 0, PI/2, get_rand(MIN_CURVE_ANGLE, PI/4)], "end");
        add_to_track(["straight", get_rand(MIN_STRAIGTH_LENGTH, MAX_STRAIGTH_LENGTH)], "end");
        //
        var side = random_choice([1,-1]);
        var L1 = get_rand(MAX_STRAIGTH_LENGTH/3, MAX_STRAIGTH_LENGTH);
        var L2 = get_rand(MAX_STRAIGTH_LENGTH/3, MAX_STRAIGTH_LENGTH);
        var R = get_rand(MIN_CURVE_RADIUS, 1.1*MIN_CURVE_RADIUS);
        var dangle = get_rand(0.9*PI, 1.1*PI);
        add_to_track(["straight", L1],"end");
        add_to_track(["curve", R, side*PI/2, dangle], "end");
        add_to_track(["straight", L2], "end");
        //
        var angle = random_choice([-PI/2,PI/2]);
        add_to_track(["curve", get_rand(MIN_CURVE_RADIUS, 2*MIN_CURVE_RADIUS), angle, get_rand(PI*0.6,PI*0.6)], "end");
        add_to_track(["straight", get_rand(MIN_STRAIGTH_LENGTH, MAX_STRAIGTH_LENGTH)], "end");
    }

    function generate_track(){
        track_history = [];
        // 1. Create base shape ////////////////////////////////////////////////
        var v = [1,0];
        points = [];
        for(var i=0; i<nstart; i++){
            var length = get_rand((1.-dR)*R, (1.+dR)*R);
            var teta = get_rand((1.-dA)*delta_angle, (1.+dA)*delta_angle);
            v = get_rotated_vector(v, teta);
            points.push([v[0]*length + W/2, v[1]*length + H/2]);
        }

        // 2. Modify base shape ////////////////////////////////////////////////
        START = points[0];
        x = START[0];
        y = START[1];
        for(var i=0; i<nstart-1; i++){
            if(get_rand(0,1) < PROB_SPECIAL_SECTION){
                var choice = random_choice(RANDOM_SECTIONS);
                if(choice == "hairpin")
                    hairpin_curve();
                else if(choice == "s")
                    s_curves();
                else if(choice == "varying")
                    varying_radius_curve(0.5);
                else if(choice == "chicane")
                    chicane();
                else
                    throw "unknown special section " + choice;
            }
            else{
                var n = Math.floor(get_rand(MIN_N_RANDOM_SECTION, MAX_N_RANDOM_SECTION));
                random_section(n);
            }
            var s = ["osef","osef",[x,y,points[i+1][0],points[i+1][1]]];
            if(check_self_collisions_straight(s,track_history.length)>0,false)
                return false;
            link_points([x,y], points[i+1], "end");
        }
        var s = ["osef","osef",[points[nstart-1][0],points[nstart-1][1],points[0][0],points[0][1]]];
        if(check_self_collisions_straight(s,track_history.length)>0,false)
            return false;
        link_points(points[nstart-1], points[0], "end");
        // 3. Smooth radius 0 corners //////////////////////////////////////////
        if(!smooth_corner(0, "auto"))
            return false;
        for(var i=1; i<track_history.length-1; i++){ //dont smooth first and last corners
            if (track_history[i][0] == "curve"){
                if(track_history[i][1] == 0){
                    if(!smooth_corner(i, "none"))
                        return false;
                }
            }
        }
        return true;
    }

    function stl_collide(){
        return false;
        // var track_width = 40;
        // var tol = Math.floor(track_width / STL_RES);
        // var L = centerline.length;
        // console.log("STL COLLIDE", L)
        // for (var i=0; i<L-1; i++){
        //     for (var j=i+1; j<L; j++){
        //         var far = j - i > tol;
        //         var far2 = i + (L-j) > tol;
        //         if(far && far2){
        //             var d = compute_distance(centerline[i],centerline[j]);
        //             if(d < track_width){
        //                 console.log("STL COLLIDE FAIL")
        //                 return true;
        //             }
        //         }
        //     }
        // }
        // console.log("STL COLLIDE OK")
        // return false;
    }

    function get_box(){
        var xvals = [];
        var yvals = [];
        for(var i=0; i<centerline.length; i++){
            xvals.push(centerline[i][0]);
            yvals.push(centerline[i][1]);
        }
        return [Math.min(xvals), Math.max(xvals), Math.min(yvals), Math.max(yvals)];
    }

    function close_numbers(n1,n2){
        var tolerance = 1e-8;
        return Math.abs(n1-n2) < tolerance;
    }

    function get_bissection_for_stl(p0,p1,p2){
        var v_before = [p1[0]-p0[0], p1[1]-p0[1]];
        var v_after = [p2[0]-p1[0], p2[1]-p1[1]];
        var angle = compute_relative_angle(v_before, v_after);
        var counterclockwise = false;
        if (angle > 0){
            angle += 2*PI; //wtf i dont know why i need this...
            counterclockwise = true;
        }
        angle = PI - angle;
        var bissection = get_normalized(v_before);
        bissection[0] *= TRACK_WIDTH;
        bissection[1] *= TRACK_WIDTH;
        if(counterclockwise)
            bissection = get_rotated_vector(bissection, angle/2)
        else
            bissection = get_rotated_vector(bissection, -angle/2)
        if(Number.isNaN(bissection[0]))
            throw "cannot find a bissection";
        return [bissection[0] + p1[0], bissection[1] + p1[1]];
    }

    function control_stl(){
        var tolerance = STL_RES / 10;
        var to_delete = [];
        for(var i=0; i<centerline.length-1; i++){
            var p = centerline[i];
            var q = centerline[i+1];
            if(compute_distance(p,q)<tolerance)
                    to_delete.push(i+1);
        }
        for(var i=to_delete.length-1; i>=0; i--)
            centerline.splice(i,1);
    }


    var HEIGHT_OFFSET = 15;
    var HEIGHT_FACTOR = get_rand(0, 40);
    var HEIGHT_FREQUENCY = Math.floor(get_rand(1,3));
    function get_track_h(i){
        if(HEIGHT_FREQUENCY<1)
            return HEIGHT_OFFSET;
        var T = centerline.length / HEIGHT_FREQUENCY;
        var prefactor = 1 + 0.2*Math.cos(i*2*PI/(centerline.length/4));
        return HEIGHT_FACTOR*(1 + prefactor*Math.sin(i*2*PI/T)) + HEIGHT_OFFSET;
    }

    function get3d(p, i){
        var z = get_track_h(i);
        return [p[0], p[1], z];
    }


    function generate_triangles(){
        var triangles = [];
        for(var i=0; i<centerline.length; i++){
            var i_before = i - 1;
            var i_after = i + 1;
            var i_after_after = i + 2;
            if(i == 0)
                i_before = centerline.length - 1;
            if(i == centerline.length - 1){
                i_after = 0;
                i_after_after = 1;
            }
            if(i == centerline.length - 2){
                i_after_after = 0;
            }
            var p0 = centerline[i_before];
            var p1 = centerline[i];
            var p2 = centerline[i_after];
            var p3 = centerline[i_after_after];
            //
            var bsc_here = get_bissection_for_stl(p0,p1,p2);
            var bsc_next = get_bissection_for_stl(p1,p2,p3);
            p1 = get3d(p1,i);
            p2 = get3d(p2,i_after);
            bsc_here = get3d(bsc_here,i);
            bsc_next = get3d(bsc_next,i_after);
            triangles.push([p1, p2, bsc_here]);
            triangles.push([bsc_here, p2, bsc_next]);

        }
        return triangles;
    }

    function stl_triangle(s,n,v1,v2,v3){
        s += "  facet normal " + n[0] + " " + n[1] + " " + n[2] + "\n";
        s += "      outer loop\n";
        // s += "          vertex " + v3[0] + " " + v3[1] + " " + v3[2] + "\n";
        // s += "          vertex " + v2[0] + " " + v2[1] + " " + v2[2] + "\n";
        // s += "          vertex " + v1[0] + " " + v1[1] + " " + v1[2] + "\n";
        //inverted normal
        s += "          vertex " + v1[0] + " " + v1[1] + " " + v1[2] + "\n";
        s += "          vertex " + v2[0] + " " + v2[1] + " " + v2[2] + "\n";
        s += "          vertex " + v3[0] + " " + v3[1] + " " + v3[2] + "\n";
        s += "      endloop\n";
        s += "  endfacet\n";
        return s;
    }

    function itr(t){
        return [t[2],t[1],t[0]];
    }

    function get_box_triangles(x,y,z, L,W,H){
        var p = [x, y, z];
        var px = [x+L, y, z];
        var py = [x, y+W, z];
        var pz = [x, y, z+H];
        var pxy = [x+L, y+W, z];
        var pxz = [x+L, y, z+H];
        var pyz = [x, y+W, z+H];
        var pxyz = [x+L, y+W, z+H];
        //
        var txy1 = itr([py, px, p]);
        var txy2 = itr([pxy, px, py]);
        var txz1 = itr([p, px, pz]);
        var txz2 = itr([pz, px, pxz]);
        var tyz1 = [p, py, pz];
        var tyz2 = [pz, py, pyz];
        //
        var txy1z = itr([pz, pxz, pyz]);
        var txy2z = itr([pyz, pxz, pxyz]);
        var txz1y = [py, pxy, pyz];
        var txz2y = [pyz, pxy, pxyz];
        var tyz1x = itr([px, pxy, pxz]);
        var tyz2x = itr([pxz, pxy, pxyz]);
        //
        var triangles = [txy1,txy2,txz1,txz2,tyz1,tyz2,
                         txy1z,txy2z,txz1y,txz2y,tyz1x,tyz2x];
        return triangles;

    }

    function get_limits(){
        var xpoints = [];
        var ypoints = [];
        for(var i=0; i<centerline.length; i++){
            xpoints.push(centerline[i][0]);
            ypoints.push(centerline[i][1]);
        }
        var mx = Math.min(...xpoints);
        var Mx = Math.max(...xpoints);
        var my = Math.min(...ypoints);
        var My = Math.max(...ypoints);
        return [mx,Mx,my,My];
    }

    function get_stl_str(triangles, ground_z){//t is a list of triangles
        var limits = get_limits();
        var mx = limits[0];
        var Mx = limits[1];
        var my = limits[2];
        var My = limits[3];
        var dx = -mx -(Mx-mx)/2;
        var dy = -my -(My-my)/2;
        console.log("DELTA", dx, dy);
        console.log("minmax xy", mx, Mx, my, My);
        var s = "solid track\n";
        for(var i=0; i<triangles.length; i++){
            var t = triangles[i];
            var v1 = [-(t[0][0]+dx), t[0][1]+dy, t[0][2]];
            var v2 = [-(t[1][0]+dx), t[1][1]+dy, t[1][2]];
            var v3 = [-(t[2][0]+dx), t[2][1]+dy, t[2][2]];
            var n = [0, 0, 1] //TODO: vectorial product
            s = stl_triangle(s, n, v1, v2, v3);
            // thickness (opposide side)
            n = [n[0], n[1], -n[2]];
            //simple thickness
            // var v1b = [v1[0], v1[1], v1[2]-TRACK_WIDTH/2];
            // var v2b = [v2[0], v2[1], v2[2]-TRACK_WIDTH/2];
            // var v3b = [v3[0], v3[1], v3[2]-TRACK_WIDTH/2];
            // s = stl_triangle(s, n, v3b, v2b, v1b);
            // to the ground
            var v1b = [v1[0], v1[1], ground_z];
            var v2b = [v2[0], v2[1], ground_z];
            var v3b = [v3[0], v3[1], ground_z];
            s = stl_triangle(s, n, v3b, v2b, v1b);
            // thickness (vertical sides)
            if(i%2 == 0){ //v3 is the bissection point
                s = stl_triangle(s, [0,0,0], v1b, v2b, v2);
                s = stl_triangle(s, [0,0,0], v1b, v2, v1);
            }
            else{ //v1 is bissection here, v3 is bissection next [bsc_here, p2, bsc_next]
                s = stl_triangle(s, [0,0,0], v1b, v1, v3);
                s = stl_triangle(s, [0,0,0], v1b, v3, v3b);
            }
        }
        s += "endsolid track";
        return s;
    }

    function download(filename, text) {
        var element = document.createElement('a');
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        element.setAttribute('download', filename);

        element.style.display = 'none';
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
    }

    function download_track(){
        var t = generate_triangles();
        var stl_str = get_stl_str(t, -10);
        download('track.stl', stl_str);
    }


    var track_history;
    // var colors = ["yellow", "blue"];
    var colors = ["black"];
    var drawing = false;
    var current_orientation = [1.,0.];
    var x, y;
    var START;
    var nstart = Math.floor(get_rand(3,7));


    //User defined avariables
    var PROB_CURVE = 0.8;
    var MAX_N_RANDOM_SECTION = 5;
    var MIN_N_RANDOM_SECTION = 0;
    var PROB_SPECIAL_SECTION = 0.5;
    var RANDOM_SECTIONS = ["hairpin", "hairpin",
                            "s", "s", "s",
                            "varying", "varying", "varying",
                            "chicane", "chicane", "chicane", "chicane"]
    var delta_angle = PI * 2. / nstart;
    var dR = 0.3;
    var dA = 0.5;
    var R = 150;
    var MAX_STRAIGTH_LENGTH = R/3;
    var MIN_STRAIGTH_LENGTH = R/10;
    var MIN_CURVE_RADIUS = R/15;
    var MAX_CURVE_RADIUS = R/2;
    var MIN_CURVE_ANGLE = PI/10;
    var MAX_CURVE_ANGLE = 0.9*PI;
    var SMOOTH_MIN_RADIUS_FACTOR = 0.9;
    var SMOOTH_MAX_RADIUS_FACTOR = 0.9;
    var PROB_COUNTERCLOCKWISE_TURN = 0.1;

    var MARGIN_LINE_LINE = R/10;
    var MARGIN_CURVE_CURVE = R/10;
    var MARGIN_BORDER = R/10;
    var MARGIN_CURVE_LINE = R/10;

    var STL_RES = 2;
    var NMAX_TRIALS = 10000;



    var itrials = 0;
    var has_collisions;
    for(var i=0; i<NMAX_TRIALS; i++){
        var t = generate_track();
        if(t){
            var has_collisions = control_collisions();
            if (!has_collisions){
                draw_track(track_history);
                if(!stl_collide())
                {
                    console.log("Track generated after", i, "trials");
                    itrials = i;
                    break;
                }
            }
        }
    }

    var all_curves = [];
    for(var i=0; i<track_history.length; i++)
        if(track_history[i][0] == "curve"){
            all_curves.push(track_history[i][1]);
        }
    var min_radius = Math.min(...all_curves);
    if(min_radius > MIN_CURVE_RADIUS)
        min_radius = MIN_CURVE_RADIUS;
    TRACK_WIDTH = min_radius/2 - 1;
    ctx.lineWidth = TRACK_WIDTH;
    if(t && !has_collisions){
        ctx.clearRect(0, 0, W, H);
        centerline = [];
        draw_track(track_history);
        // ctx.fillRect(START[0], START[1], 6,6);
        // for(var i =0;i<points.length;i++)
        //     ctx.fillRect(points[i][0], points[i][1], 3,3);
        console.log("Number of track elements = ", track_history.length);

        // ctx.fillStyle = "blue";
        // control_stl();
        console.log(centerline.length, centerline.length*STL_RES);
        // for(var i=0; i<centerline.length; i++){
        //     var p = centerline[i];
        //     ctx.fillRect(p[0],p[1],2,2);
        // }

    }
    else{
        console.log("FAIL");
        window.location.reload(false);
    }


    //TODO: supprimer in_canvas et recentrer circuit apres coup

    //TODO: controle post-generation des collisions : par "pixels" au moment du stl
    //SEULEMENT SI BESOIN :
    //TODO: vecteur de "force" (proba gaussienne centre sur un angle) qui va de la bissectrice en debut de sections
        // au vecteur colineaire en fin de section
        //TODO: heuristique : interdire de se rapprocher trop du centre du polygone de base

    // control_collisions();


    console.log(itrials);

    // console.log(t);

    // console.log(stl_str);
</script>

<div id="scene3d"> </div>


<!-- <script src="three.js"></script> -->
<!-- <script src="../webgl/three/src/Three.js" type="module"></script>
<script src="stats.js"></script> -->
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script> -->

 <script src="../three/three.js-master/build/three.js"></script>

 <script src="../three/three.js-master/examples/js/controls/OrbitControls.js"></script>
<!-- <script src="three@0.99.0/examples/js/controls/OrbitControls.js" ></script> -->

<script src="./render.js"></script>
<!--
A FAIRE:
CONSTRUIRE GEOMETRY DIRECT (PAS PASSER PAR FICHIER)
NE PAS AVOIR A METTRE UNE EPAISSEUR -->
<br>
<div>
<button onclick="download_track();"> Download track </button>
</div>
</body>
</html>

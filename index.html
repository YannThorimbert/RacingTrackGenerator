<!DOCTYPE html>
<html>
<body>

<canvas id="myCanvas" width="600" height="600" style="border:1px solid #d3d3d3;">
Your browser does not support the HTML5 canvas tag.</canvas>

<script>
    var PI = Math.PI;
    var c = document.getElementById("myCanvas");
    var W = c.width;
    var H = c.height;
    var ctx = c.getContext("2d");
    ctx.beginPath();

    function random_choice(a){
        return a[Math.floor(Math.random() * a.length)];
    }

    function get_rand(m,M){
        return m + Math.random() * (M-m);
    }

    function compute_distance(p1, p2){
        return Math.hypot(p1[0]-p2[0], p1[1]-p2[1]);
    }

    function compute_distance_point_line(x, y, q){
        var dx = q[2] - q[0];
        var dy = q[3] - q[1];
        if (dx == 0){
            return Math.abs(q[0] - x);
        }
        else{
            var a = dy / dx;
            var b = q[1] - a*q[0];
            console.log(a, b)
            return Math.abs(y - a*x - b) / Math.sqrt(1 + a*a);
        }
    }

    function compute_min_dist_segments(q1, q2){
        var a = compute_distance([q1[0], q1[1]], [q2[0], q2[1]]);
        var b = compute_distance([q1[0], q1[1]], [q2[2], q2[3]]);
        var c = compute_distance([q1[2], q1[3]], [q2[0], q2[1]]);
        var d = compute_distance([q1[2], q1[3]], [q2[2], q2[3]]);
        return Math.min(a,b,c,d);
    }

    function get_current_angle(){
        return Math.atan2(current_orientation[1],current_orientation[0]);
    }

    function compute_norm(v){
        return Math.sqrt(v[0]*v[0] + v[1]*v[1]);
    }

    function get_normalized(v){
        var L = compute_norm(v);
        return [v[0]/L, v[1]/L];
    }

    function compute_relative_angle(v1,v2){
        var Lv1 = compute_norm(v1);
        var Lv2 = compute_norm(v2);
        var cos_t = (v1[0]*v2[0] + v1[1]*v2[1]) / (Lv1*Lv2);
        var det = v1[0]*v2[1] - v1[1]*v2[0];
        var sign = 1.;
        if(det > 0)
            sign = -1.;
        return sign * Math.acos(cos_t);
    }

    function get_rotated_vector(v, delta){
        return [Math.cos(delta)*v[0]-Math.sin(delta)*v[1],
                Math.sin(delta)*v[0]+Math.cos(delta)*v[1]];
    }

    function make_straight(length){
        var new_x = x + current_orientation[0] * length;
        var new_y = y + current_orientation[1] * length;
        if(drawing){
            ctx.moveTo(x,y);
            ctx.lineTo(new_x, new_y);
        }
        return [new_x, new_y, x, y];
    }

    function check_line_line_collision(qf, qg){ //f is the newly created straight
        var d1 = compute_distance_point_line([qf[0],qf[1]], qg);
        var d2 = compute_distance_point_line([qf[2],qf[3]], qg);
        if(d1 < MARGIN_LINE_LINE || d2 < MARGIN_LINE_LINE)
            return compute_min_dist_segments(qf, qg) < MARGIN_LINE_LINE;
        var f = [qf[2]-qf[0], qf[3]-qf[1]];
        var g = [qg[2]-qg[0], qg[3]-qg[1]];
        var min_f_y = Math.min(qf[1], qf[3]);
        var max_f_y = Math.max(qf[1], qf[3]);
        var min_f_x = Math.min(qf[0], qf[2]);
        var max_f_x = Math.max(qf[0], qf[2]);
        var min_g_y = Math.min(qg[1], qg[3]);
        var max_g_y = Math.max(qg[1], qg[3]);
        var min_g_x = Math.min(qg[0], qg[2]);
        var max_g_x = Math.max(qg[0], qg[2]);
        if(f[0] == 0){ //f has infinite slope
            if(g[1] == 0){
                return qg[1] <= max_f_y && qg[1] >= min_f_y;
            }
            else{ //invert x and y
                return true; //TODO, meanwhile lets pretend its a collision
            }
        }
        else if(g[0] == 0){ //g has infinite slope
            if(f[1] == 0){
                return qf[1] <= max_g_y && qf[1] >= min_g_y;
            }
            else{ //invert x and y
                return true; //TODO, meanwhile lets pretend its a collision
            }
        }
        var sf = f[1] / f[0];
        var sg = g[1] / g[0];
        if(sf == sg) //parallel lines (or colinear)
            return false;
        var x_col = (qg[1] - qf[1] + sf*qf[0] - sg*qg[0]) / (sf - sg);
        if(x_col >= min_f_x && x_col <= max_f_x){
            return true;
            // var y_col = sf*x_col + qf[1] - sf*qf[0];
            // return y_col >= min_f_y && y_col <= max_f_y;
        }
        return false;
    }

    function check_curve_curve_collision(r1, c1, r2, c2){
        return compute_distance(c1, c2) <= r1 + r2 + MARGIN_CURVE_CURVE;
    }

    function check_curve_line_collision(c, r, q){
        var d = compute_distance_point_line(c[0],c[1], q);
        if(d <= r){
            var D = [q[2]-q[0], q[3]-q[1]];
            var min_y = Math.min(q[1],q[3]);
            var max_y = Math.max(q[1],q[3]);
            if(D[0] == 0){
                return c[1] >= min_y && c[1] <= max_y;
            }
            var R = D[1]/D[0];
            var y = c[1] + d / Math.sqrt(1 + R*R);
            return y >= min_y && y <= max_y;
        }
        else{
            return false;
        }
    }

    function check_self_collisions_straight(straight){
        var qf = straight[2]; //straight that is candidate to be included
        if(qf.length != 4)
            throw "problem"
        for(var i=0; i<track_history.length; i++){
            var what = track_history[i];
            if( what[0] == "straight" && i!=track_history.length-1){
                var qg = what[2];
                return check_line_line_collision(qf,qg);
            }
            else{
                var c1 = what[4];
                var r1 = what[1];
                return check_curve_line_collision(c1,r1,qf);
            }
        }
        return false;
    }

    function check_self_collisions_curve(curve){
        var r1 = curve[1];
        var c1 = curve[4];
        for(var i=0; i<track_history.length; i++){
            var what = track_history[i];
            if( what[0] == "curve" && i!=track_history.length-1){
                var r2 = what[1];
                var c2 = what[4];
                if(check_curve_curve_collision(r1,c1,r2,c2))
                    return true;
            }
            else{
                var q = what[2];
                return check_curve_line_collision(c1,r1,q);
            }
        }
        return false;
    }


    function make_curve(radius, side, delta_angle){
        var a0 = get_current_angle();
        if (side < 0){
            delta_angle *= -1.;
            a0 += PI/2;
        }
        else{
            a0 -= PI/2;
        }
        var to_radius = get_rotated_vector(current_orientation, side);
        var cx = x + to_radius[0]*radius;
        var cy = y + to_radius[1]*radius;
        var a1 = a0 + delta_angle;
        if(drawing){
            // ctx.arc(cx,cy,radius,0,2*PI);
            if(side < 0)
                ctx.arc(cx,cy,radius,a1,a0);
            else
                ctx.arc(cx,cy,radius,a0,a1);
        }
        new_orientation = get_rotated_vector(current_orientation, delta_angle);
        new_x = cx + radius*Math.cos(a1);
        new_y = cy + radius*Math.sin(a1);
        return [new_x, new_y, new_orientation, [cx,cy]];
    }

    function compute_first_orientation(th){
        var v1 = get_straight_vector(th[th.length-1]);
        return get_normalized(v1);
    }

    function display(what){
        if(what[0] == "curve"){
            console.log("Curve");
            console.log("   Radius :", Math.round(what[1]));
            if(what[2]<0)
                console.log("   Anticlockwise");
            else
                console.log("   Clockwise");
            console.log("   Delta angle :", Math.round(what[3]*180/PI))
            console.log("   Center :", what[4]);
        }
    }

    function draw_track(th){ // th is track history
        console.log("DRAWING", th);
        current_orientation = compute_first_orientation(th);
        x = th[th.length-1][2][2];
        y = th[th.length-1][2][3];
        console.log("orientation set to", current_orientation);
        // current_orientation = [1,0];
        // x = START[0];
        // y = START[1];
        drawing = true;
        for(var i=0; i<th.length; i++){
            var new_pos = [];
            var new_orientation = [];
            ctx.beginPath();
            ctx.strokeStyle = colors[i%colors.length];
            var what = th[i];
            console.log(i, "drawing", what);
            // display(what);
            if(what[0] == "straight"){
                new_pos = make_straight(what[1]);
                new_orientation = current_orientation;
            }
            else if(what[0] == "curve"){
                var data = make_curve(what[1], what[2], what[3]);
                new_pos[0] = data[0];
                new_pos[1] = data[1];
                new_orientation = data[2];
            }
            ctx.stroke();
            x = new_pos[0];
            y = new_pos[1];
            console.log("       (x,y) = ",x,y);
            current_orientation = new_orientation;
        }
        //drawing = false;
    }

    function is_in_canvas(pos, margin){
        var ok_x = pos[0] > margin && pos[0] < W - margin;
        var ok_y = pos[1] > margin && pos[1] < H - margin;
        return ok_x && ok_y;
    }

    function update_track(){
        var what = random_choice(POSSIBILITIES);
        console.log(what);
        var new_pos = [];
        var new_orientation = [];
        var to_insert;
        var collision;
        if(what == "straight"){
            var length = get_rand(MIN_STRAIGTH_LENGTH, MAX_STRAIGTH_LENGTH);
            new_pos = make_straight(length);
            new_orientation = current_orientation;
            to_insert = ["straight", length, new_pos];
            collision = check_self_collisions_straight(to_insert);
        }
        else if(what == "curve"){
            var radius = get_rand(MIN_CURVE_RADIUS, MAX_CURVE_RADIUS);
            var side = random_choice([PI/2, -PI/2]);
            var delta_angle = get_rand(MIN_CURVE_ANGLE, MAX_CURVE_ANGLE);
            var data = make_curve(radius, side, delta_angle);
            new_pos[0] = data[0];
            new_pos[1] = data[1];
            new_orientation = data[2];
            var center = data[3];
            to_insert = ["curve", radius, side, delta_angle, center];
            collision = check_self_collisions_curve(to_insert);
        }
        var in_canvas = is_in_canvas(new_pos, MAX_CURVE_RADIUS + MARGIN_BORDER);
        if(in_canvas && !collision){
            console.log("(nx,ny)=",new_pos);
            x = new_pos[0];
            y = new_pos[1];
            current_orientation = new_orientation;
            track_history.push(to_insert);
        }
        else{
            console.log("Not accepted");
            // track_history.pop();
        }
    }


    function add_to_track(what, i){
        if(i="end"){
            i = track_history.length;
        }
        if(what[0] == "straight"){
            var q = make_straight(what[1]);
            track_history.splice(i,0,["straight", what[1], [q[2],q[3],q[0],q[1]]]);
            x = q[0];
            y = q[1];
        }
        else if(what[0] == "curve"){
            var data = make_curve(what[1], what[2], what[3]);
            x = data[0];
            y = data[1];
            current_orientation = data[2];
            var center = data[3];
            track_history.splice(i,0,["curve", what[1], what[2], what[3], center]);
        }
    }

    function link_points(q1, q2, i){
        if(i == "end"){
            i = track_history.length;
        }
        var link = [q2[0]-q1[0], q2[1]-q1[1]];
        var angle = compute_relative_angle(link, current_orientation);
        add_to_track(["curve", 0, PI/2, angle], i);
        add_to_track(["straight", compute_norm(link)], i+1);
    }

    function get_straight_vector(what){
        return [what[2][2]-what[2][0], what[2][3]-what[2][1]];
    }


    function smooth_corner(n, compute_angle){
        var curve = track_history[n];
        var cx = curve[4][0];
        var cy = curve[4][1];
        var i_before = n-1;
        if(i_before<0)
            i_before = track_history.length - 1;
        var before = track_history[i_before];
        var after = track_history[(n+1)%track_history.length];
        if(curve[0] != "curve" || before[0] != "straight" || after[0] != "straight")
            throw "PROBLEM in smooth corner"; //, curve, before, after);
        ////////////////////////////////////////////////////////////////////////
        var b_v = get_straight_vector(before);
        var b_L = compute_norm(b_v);
        var a_v = get_straight_vector(after);
        var a_L = compute_norm(a_v);
        var angle = compute_relative_angle(b_v, a_v);
        if (angle > 0){
            angle += 2*PI; //wtf i dont know why i need this...
        }
        angle = PI - angle;
        var bissection = get_normalized(b_v);
        bissection = get_rotated_vector(bissection, angle/2)
        var min_length = Math.min(b_L,a_L);
        var r = get_rand(SMOOTH_MIN_RADIUS_FACTOR*min_length,
                            SMOOTH_MAX_RADIUS_FACTOR*min_length)
        var vP = [bissection[0]*r, bissection[1]*r];
        var P = [cx + vP[0], cy + vP[1]]; //new curve center
        ////////////////////////////////////////////////////////////////////////
        // now find closest points from P on before (orthogonal projection)
        var b_x = before[2][0] - cx;
        var b_y = before[2][1] - cy;
        var lambda = (vP[0]*b_x + vP[1]*b_y) / (b_x*b_x + b_y*b_y);
        var B = [lambda*b_x + cx, lambda*b_y + cy];
        // now find closest points from P on after (orthogonal projection)
        var a_x = after[2][2] - cx;
        var a_y = after[2][3] - cy;
        var lambda = (vP[0]*a_x + vP[1]*a_y) / (a_x*a_x + a_y*a_y);
        var A = [lambda*a_x + cx, lambda*a_y + cy];
        //////////////////////////////////////////////////////////////////////
        // ctx.fillRect(before[2][2], before[2][3],12,12);
        // ctx.fillRect(after[2][2], after[2][3],12,12);
        // ctx.fillRect(B[0], B[1], 8,8);
        // ctx.fillRect(A[0], A[1], 8,8);
        // ctx.fillRect(cx, cy, 5,5);
        // ctx.fillRect(P[0], P[1], 8,8);
        ////////////////////////////////////////////////////////////////////////
        before[1] = compute_distance(B, [before[2][0], before[2][1]]); // new length
        before[2] = [before[2][0], before[2][1], B[0], B[1]];
        after[1] = compute_distance(A, [after[2][2], after[2][3]]); // new length
        after[2] = [A[0],A[1],after[2][2],after[2][3]];
        //
        curve[1] = compute_distance(P,A); //new turn radius
        curve[4] = P;
        if(angle > PI){
            angle = 2*PI - angle;
        }
        else {
            curve[2] *= -1;
            angle += 2*PI;
        }
        angle = PI - angle;
        curve[3] = angle;
    }

    function random_section(){
        add_to_track(["curve", 0, PI/2, get_rand(MIN_CURVE_ANGLE, PI/4)], "end");
        add_to_track(["straight", get_rand(MIN_STRAIGTH_LENGTH, MAX_STRAIGTH_LENGTH)], "end");
        for(var k=0; k<8; k++){
            update_track();
        }
        var angle = random_choice([-PI/2,PI/2]);
        add_to_track(["curve", get_rand(MIN_CURVE_RADIUS,MAX_CURVE_RADIUS), angle, get_rand(PI*0.6,PI*0.6)], "end");
        add_to_track(["straight", get_rand(MIN_STRAIGTH_LENGTH, MAX_STRAIGTH_LENGTH)], "end");
    }

    var POSSIBILITIES = ["straight", "curve"];
    var track_history;
    var colors = ["yellow", "blue"];
    ctx.lineWidth = "3";
    var drawing = false;
    var current_orientation = [1.,0.];
    var x, y;
    var START;

    // 1. Generate a base shape ////////////////////////////////////////////////
    var nstart = 3;
    var delta_angle = PI * 2. / nstart;
    var dR = 0.6;
    var dA = 0.25;
    // var dR = 0.;
    // var dA = 0.;
    var R = 100;
    var MAX_STRAIGTH_LENGTH = R/3;
    var MIN_STRAIGTH_LENGTH = R/10;
    var MIN_CURVE_RADIUS = R/6;
    var MAX_CURVE_RADIUS = R;
    var MIN_CURVE_ANGLE = PI/10;
    var MAX_CURVE_ANGLE = 0.75*PI;
    var SMOOTH_MIN_RADIUS_FACTOR = 0.7;
    var SMOOTH_MAX_RADIUS_FACTOR = 0.7;
    // var SMOOTH_MIN_RADIUS_FACTOR = 0.5;
    // var SMOOTH_MAX_RADIUS_FACTOR = 0.5;

    var MARGIN_LINE_LINE = 40;
    var MARGIN_CURVE_CURVE = 40;
    var MARGIN_BORDER = 40;

    function generate_track(){
        track_history = [];

        // 1. Create base shape ////////////////////////////////////////////////
        var v = [1,0];
        points = [];
        for(var i=0; i<nstart; i++){
            var length = get_rand((1.-dR)*R, (1.+dR)*R);
            var teta = get_rand((1.-dA)*delta_angle, (1.+dA)*delta_angle);
            v = get_rotated_vector(v, teta);
            points.push([v[0]*length + W/2, v[1]*length + H/2]);
        }

        // 2. Modify base shape ////////////////////////////////////////////////
        START = points[0];
        x = START[0];
        y = START[1];
        for(var i=0; i<nstart-1; i++){
            random_section();
            var s = ["osef","osef",[x,y,points[i+1][0],points[i+1][1]]];
            if(check_self_collisions_straight(s))
                return false;
            link_points([x,y], points[i+1], "end");
        }
        var s = ["osef","osef",[points[nstart-1][0],points[nstart-1][1],points[0][0],points[0][1]]];
        if(check_self_collisions_straight(s))
            return false;
        link_points(points[nstart-1], points[0], "end");
        // 3. Smooth radius 0 corners //////////////////////////////////////////
        smooth_corner(0, "auto");
        for(var i=1; i<track_history.length-1; i++){ //dont smooth first and last corners
            if (track_history[i][0] == "curve"){
                if(track_history[i][1] == 0){
                    console.log("smooth",i);
                    smooth_corner(i, "none");
                }
            }
        }
        return true;
    }

    var t = false;
    while (!t){
        t = generate_track();
    }
    if(t){
        draw_track(track_history);
        ctx.fillRect(START[0], START[1], 6,6);
        // for(var i =0;i<points.length;i++)
        //     ctx.fillRect(points[i][0], points[i][1], 3,3);
        console.log("Number of track elements = ", track_history.length);
    }
    //TODO: controle post-generation des collisions

    //TODO: pk curve_line marche tj pas ?
    //TODO: rajouter margin a curve line

    //TODO: parametriser longueur des random section
    //TODO: favoriser les angles clockwise d'un certain facteur pour defavoriser les huit
    //TODO: heuristique : interdire de se rapprocher trop du centre du polygone de base
    //TODO: au moment du smooth, si ca implique une courbure trop petite, rajouter au bol des virages+droites ;
    // ou plutot, si point trop pres du prochain point cible, refaire un petit random section

    //TODO: distributions et sequences (chicanes, spirales, anguleux, serpent)

</script>

</body>
</html>
